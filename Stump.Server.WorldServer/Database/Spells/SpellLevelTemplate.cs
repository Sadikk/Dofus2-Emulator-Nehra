using Stump.Core.IO;
using Stump.Core.Reflection;
using Stump.DofusProtocol.Classes;
using Stump.DofusProtocol.Tools.D2o;
using Stump.ORM;
using Stump.ORM.SubSonic.SQLGeneration.Schema;
using Stump.Server.WorldServer.Game.Effects;
using Stump.Server.WorldServer.Game.Effects.Instances;
using Stump.Server.WorldServer.Game.Spells;
using System.Linq;

namespace Stump.Server.WorldServer.Database.Spells
{
	[D2OClass("SpellLevel", "com.ankamagames.dofus.datacenter.spells", true), TableName("spells_levels")]
	public class SpellLevelTemplate : IAutoGeneratedRecord, ISaveIntercepter, IAssignedByD2O
	{
		private System.Collections.Generic.List<EffectDice> m_criticalEffects;
		private byte[] m_criticalEffectsBin;
		private System.Collections.Generic.List<EffectDice> m_effects;
		private byte[] m_effectsBin;
		private SpellTemplate m_spell;
		private string m_statesForbiddenCSV;
		private string m_statesRequiredCSV;

		[PrimaryKey("Id", false)]
		public uint Id
		{
			get;
			set;
		}
		public uint SpellId
		{
			get;
			set;
		}
		public SpellTemplate Spell
		{
			get
			{
				SpellTemplate arg_23_0;
				if ((arg_23_0 = this.m_spell) == null)
				{
					arg_23_0 = (this.m_spell = Singleton<SpellManager>.Instance.GetSpellTemplate((int)this.SpellId));
				}
				return arg_23_0;
			}
		}
		public uint SpellBreed
		{
			get;
			set;
		}
		public uint ApCost
		{
			get;
			set;
		}
		public uint Range
		{
			get;
			set;
		}
		public bool CastInLine
		{
			get;
			set;
		}
		public bool CastInDiagonal
		{
			get;
			set;
		}
		public bool CastTestLos
		{
			get;
			set;
		}
		public uint CriticalHitProbability
		{
			get;
			set;
		}
		public string StatesRequiredCSV
		{
			get
			{
				return this.m_statesRequiredCSV;
			}
			set
			{
				this.m_statesRequiredCSV = value;
                this.StatesRequired = this.m_statesRequiredCSV.FromCSV<int>(",");
			}
		}
		[Ignore]
		public int[] StatesRequired
		{
			get;
			set;
		}
		public uint CriticalFailureProbability
		{
			get;
			set;
		}
		public bool NeedFreeCell
		{
			get;
			set;
		}
		public bool NeedFreeTrapCell
		{
			get;
			set;
		}
		public bool NeedTakenCell
		{
			get;
			set;
		}
		public bool RangeCanBeBoosted
		{
			get;
			set;
		}
		public int MaxStack
		{
			get;
			set;
		}
		public uint MaxCastPerTurn
		{
			get;
			set;
		}
		public uint MaxCastPerTarget
		{
			get;
			set;
		}
		public uint MinCastInterval
		{
			get;
			set;
		}
		public uint InitialCooldown
		{
			get;
			set;
		}
		public int GlobalCooldown
		{
			get;
			set;
		}
		public uint MinPlayerLevel
		{
			get;
			set;
		}
		public bool CriticalFailureEndsTurn
		{
			get;
			set;
		}
		public bool HideEffects
		{
			get;
			set;
		}
		public bool Hidden
		{
			get;
			set;
		}
		public uint MinRange
		{
			get;
			set;
		}
		public string StatesForbiddenCSV
		{
			get
			{
				return this.m_statesForbiddenCSV;
			}
			set
			{
				this.m_statesForbiddenCSV = value;
                this.StatesForbidden = value.FromCSV<int>(",");
			}
		}
		[Ignore]
		public int[] StatesForbidden
		{
			get;
			set;
		}
		public byte[] EffectsBin
		{
			get
			{
				return this.m_effectsBin;
			}
			set
			{
				this.m_effectsBin = value;
				this.m_effects = Singleton<EffectManager>.Instance.DeserializeEffects(this.EffectsBin).Cast<EffectDice>().ToList<EffectDice>();
			}
		}
		[Ignore]
		public System.Collections.Generic.List<EffectDice> Effects
		{
			get
			{
				System.Collections.Generic.List<EffectDice> arg_2D_0;
				if ((arg_2D_0 = this.m_effects) == null)
				{
					arg_2D_0 = (this.m_effects = Singleton<EffectManager>.Instance.DeserializeEffects(this.EffectsBin).Cast<EffectDice>().ToList<EffectDice>());
				}
				return arg_2D_0;
			}
			set
			{
				this.m_effects = value;
			}
		}
		public byte[] CriticalEffectsBin
		{
			get
			{
				return this.m_criticalEffectsBin;
			}
			set
			{
				this.m_criticalEffectsBin = value;
				this.m_criticalEffects = Singleton<EffectManager>.Instance.DeserializeEffects(this.CriticalEffectsBin).Cast<EffectDice>().ToList<EffectDice>();
			}
		}
		[Ignore]
		public System.Collections.Generic.List<EffectDice> CriticalEffects
		{
			get
			{
				System.Collections.Generic.List<EffectDice> arg_2D_0;
				if ((arg_2D_0 = this.m_criticalEffects) == null)
				{
					arg_2D_0 = (this.m_criticalEffects = Singleton<EffectManager>.Instance.DeserializeEffects(this.CriticalEffectsBin).Cast<EffectDice>().ToList<EffectDice>());
				}
				return arg_2D_0;
			}
			set
			{
				this.m_criticalEffects = value;
			}
		}
		public void AssignFields(object d2oObject)
		{
			SpellLevel spellLevel = (SpellLevel)d2oObject;
			this.Id = (uint)spellLevel.id;
			this.SpellId = spellLevel.spellId;
			this.SpellBreed = spellLevel.spellBreed;
			this.ApCost = spellLevel.apCost;
			this.Range = spellLevel.range;
			this.CastInLine = spellLevel.castInLine;
			this.CastInDiagonal = spellLevel.castInDiagonal;
			this.CastTestLos = spellLevel.castTestLos;
			this.CriticalHitProbability = spellLevel.criticalHitProbability;
			this.StatesRequired = spellLevel.statesRequired.ToArray();
			this.CriticalFailureProbability = spellLevel.criticalFailureProbability;
			this.NeedFreeCell = spellLevel.needFreeCell;
			this.NeedFreeTrapCell = spellLevel.needFreeTrapCell;
			this.NeedTakenCell = spellLevel.needTakenCell;
			this.RangeCanBeBoosted = spellLevel.rangeCanBeBoosted;
			this.MaxStack = spellLevel.maxStack;
			this.MaxCastPerTarget = spellLevel.maxCastPerTarget;
			this.MinCastInterval = spellLevel.minCastInterval;
			this.InitialCooldown = spellLevel.initialCooldown;
			this.GlobalCooldown = spellLevel.globalCooldown;
			this.MinPlayerLevel = spellLevel.minPlayerLevel;
			this.CriticalFailureEndsTurn = spellLevel.criticalFailureEndsTurn;
			this.HideEffects = spellLevel.hideEffects;
			this.Hidden = spellLevel.hidden;
			this.MinRange = spellLevel.minRange;
			this.StatesForbidden = spellLevel.statesForbidden.ToArray();
			this.m_effectsBin = Singleton<EffectManager>.Instance.SerializeEffects(spellLevel.effects);
			this.m_criticalEffectsBin = Singleton<EffectManager>.Instance.SerializeEffects(spellLevel.criticalEffect);
		}
		public void BeforeSave(bool insert)
		{
			this.m_statesForbiddenCSV = this.StatesForbidden.ToCSV(",");
			this.m_statesRequiredCSV = this.StatesRequired.ToCSV(",");
			this.m_effectsBin = Singleton<EffectManager>.Instance.SerializeEffects(this.Effects);
			this.m_criticalEffectsBin = Singleton<EffectManager>.Instance.SerializeEffects(this.CriticalEffects);
		}


	}
}
